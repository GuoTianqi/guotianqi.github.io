<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>郭天祈的个人博客</title>
  
  <subtitle>代码如诗</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://guotianqi.xyz/"/>
  <updated>2018-05-26T06:42:19.376Z</updated>
  <id>https://guotianqi.xyz/</id>
  
  <author>
    <name>郭天祈</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Mac下编译Android源码，并导入IntelliJ IDEA进行源码阅读</title>
    <link href="https://guotianqi.xyz/2018/05/26/aosp-compile-on-mac/"/>
    <id>https://guotianqi.xyz/2018/05/26/aosp-compile-on-mac/</id>
    <published>2018-05-26T06:06:49.000Z</published>
    <updated>2018-05-26T06:42:19.376Z</updated>
    
    <content type="html"><![CDATA[<ul><li>macOS High Sierra 版本 10.13.4</li><li>Xcode 9.3</li><li>aosp分支：android-8.1.0_r20</li></ul><h1 id="准备编译环境"><a href="#准备编译环境" class="headerlink" title="准备编译环境"></a>准备编译环境</h1><p>具体参考<a href="https://source.android.com/setup/build/initializing" title="Establishing a Build Environment" target="_blank" rel="noopener">官方文档</a></p><ol><li>安装 <a href="http://www.oracle.com/technetwork/java/javase/downloads/java-archive-javase8-2177648.html#jdk-8u45-oth-JPR" target="_blank" rel="noopener">jdk8u45 or newer</a></li><li><p>安装xcode命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure></li><li><p>安装编译需要用到的其他包<br>使用<a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a>安装(<a href="https://source.android.com/setup/build/initializing" title="Establishing a Build Environment" target="_blank" rel="noopener">官方文档</a>使用的是<a href="https://www.macports.org/install.php" target="_blank" rel="noopener">MacPorts</a>)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gmake libsdl git gnupg</span><br></pre></td></tr></table></figure></li></ol><p><em><strong>NOTE</strong></em>: gmake 可以不用安装，使用xcode自带的就可以</p><ol start="4"><li><p>设置可以同时打开的文件数限制，避免编译时超出限制<br>在 ~/.bash_profile 添加如下语句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># set the number of open files to be 1024</span><br><span class="line">ulimit -S -n 1024</span><br></pre></td></tr></table></figure></li><li><p>创建区分大小写的APFS宗卷<br><a href="https://source.android.com/setup/build/initializing" title="Establishing a Build Environment" target="_blank" rel="noopener">官方文档</a>创建的是区分大小写HFS+磁盘镜像，我们这边使用<strong>区分大小写的APFS卷宗</strong><br><img src="http://blog.guotianqi.xyz/image/aosp_compile_on_mac/APFS宗卷描述.png" alt="APFS宗卷描述.png"></p><ol><li>打开磁盘工具按下图步骤操作：<br><img src="http://blog.guotianqi.xyz/image/aosp_compile_on_mac/添加APFS卷宗.png" alt="添加APFS卷宗.png"></li><li>设置宗卷大小<br>具体大小根据自己情况设定，配额大小最好不要小于<strong>200G</strong><br><img src="http://blog.guotianqi.xyz/image/设置APFS卷宗大小.png" alt="设置APFS卷宗大小.png"></li></ol></li></ol><h1 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h1><p>具体参考<a href="https://source.android.com/setup/build/downloading" title="Downloading the Source" target="_blank" rel="noopener">官方文档-下载源码</a>。<br>本文使用<a href="https://mirror.tuna.tsinghua.edu.cn/help/AOSP/" title="清华大学aosp下载教程" target="_blank" rel="noopener">清华大学aosp镜像</a>下载源码，具体步骤参考<a href="https://mirror.tuna.tsinghua.edu.cn/help/AOSP/" title="清华大学aosp下载教程" target="_blank" rel="noopener">清华大学aosp镜像</a>提供的教程。</p><ol><li>下载repo<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/bin</span><br><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo</span><br><span class="line">chmod +x ~/bin/repo</span><br></pre></td></tr></table></figure></li></ol><p>在~/.bash_profile中将刚才创建的<code>~/bin</code>目录添加进<code>PATH</code>中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=~/bin:$PATH</span><br></pre></td></tr></table></figure></p><ol start="2"><li><p>建立工作目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir WORKING_DIRECTORY</span><br><span class="line">cd WORKING_DIRECTORY</span><br></pre></td></tr></table></figure></li><li><p>初始化仓库<br>指定master分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest</span><br></pre></td></tr></table></figure></li></ol><p>若要指定<a href="https://source.android.com/source/build-numbers#source-code-tags-and-builds" target="_blank" rel="noopener">android版本</a>，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-8.1.0_r20</span><br></pre></td></tr></table></figure></p><ol start="4"><li>同步源码树<br><code>repo sync</code> 或者  <code>repo sync -j4  # 指定并发数</code><br><strong>NOTE:</strong>  <code>repo sync</code>有时会失败，可能要运行多次，才能同步完源码，可以使用以下循环脚本：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line">repo sync -j4</span><br><span class="line"><span class="keyword">while</span> [ $? -ne 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    repo sync -j4</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="编译源码"><a href="#编译源码" class="headerlink" title="编译源码"></a>编译源码</h1><p>具体参考<a href="https://source.android.com/setup/build/building" title="编译源码" target="_blank" rel="noopener">官方文档-编译源码</a><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh</span><br><span class="line">lunch aosp_x86_64-eng <span class="comment"># 或者直接运行lunch， 在出现的选项中选择编译目标</span></span><br><span class="line">make -j8 <span class="comment"># 根据cpu核心数（物理线程）选择并发数，公式：并发数=cpu核心数（物理线程） x 2</span></span><br></pre></td></tr></table></figure></p><p>编译过程比较漫长，在我的机子上大概用了2个多小时</p><h2 id="编译遇到的问题"><a href="#编译遇到的问题" class="headerlink" title="编译遇到的问题"></a>编译遇到的问题</h2><ol><li><strong>mac sdk10.13</strong> 不支持编译，如下：<br><em>internal error: Could not find a supported mac sdk: [“10.10” “10.11” “10.12”]</em><blockquote><p>[44/44] bootstrap out/soong/.minibootstrap/build.ninja.in<br>[4/4] out/soong/.bootstrap/bin/minibp out/soong/.bootstrap/build.ninja<br>[860/861] glob external/clang/utils/TableGen/Android.bp<br>[54/54] out/soong/.bootstrap/bin/soong_build out/soong/build.ninja<br>FAILED: out/soong/build.ninja<br>out/soong/.bootstrap/bin/soong_build  -t -b out/soong -d out/soong/build.ninja.d -o out/soong/build.ninja Android.bp<br>internal error: Could not find a supported mac sdk: [“10.10” “10.11” “10.12”]<br>ninja: build stopped: subcommand failed.<br>20:24:32 soong failed with: exit status 1</p></blockquote></li></ol><p><strong>解决方法</strong><br>修改AOSP/build/soong/cc/config/x86_darwin_host.go文件，添加10.13支持，如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">darwinSupportedSdkVersions = []<span class="keyword">string</span>&#123;</span><br><span class="line">    <span class="string">"10.10"</span>,</span><br><span class="line">    <span class="string">"10.11"</span>,</span><br><span class="line">    <span class="string">"10.12"</span>,</span><br><span class="line">    <span class="string">"10.13"</span>, <span class="comment">// 添加mac sdk 10.13</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>遇到<code>bison</code>错误<blockquote><p>FAILED: out/soong/.intermediates/external/selinux/checkpolicy/checkpolicy/darwin_x86_64/gen/yacc/external/selinux/checkpolicy/policy_parse.c out/soong/.intermediates/external/selinux/checkpolicy/checkpolicy/darwin_x86_64/gen/yacc/external/selinux/checkpolicy/policy_parse.h<br>BISON_PKGDATADIR=external/bison/data prebuilts/misc/darwin-x86/bison/bison -d  –defines=out/soong/.intermediates/external/selinux/checkpolicy/checkpolicy/darwin_x86_64/gen/yacc/external/selinux/checkpolicy/policy_parse.h -o out/soong/.intermediates/external/selinux/checkpolicy/checkpolicy/darwin_x86_64/gen/yacc/external/selinux/checkpolicy/policy_parse.c external/selinux/checkpolicy/policy_parse.y</p></blockquote></li></ol><p><strong>解决方法</strong><br>为<code>bison</code>打补丁，重新编译(Patch <a href="https://android-review.googlesource.com/c/platform/external/bison/+/517740" target="_blank" rel="noopener">bison fix</a> for High Sierra and build bison:)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> AOSP/external/bison</span><br><span class="line">git cherry-pick c0c852bd6fe462b148475476d9124fd740eba160</span><br><span class="line">mm</span><br><span class="line">cp AOSP/out/host/darwin-x86/bin/bison AOSP/prebuilts/misc/darwin-x86/bison/</span><br></pre></td></tr></table></figure></p><h1 id="将源码导入IntelliJ-IDEA"><a href="#将源码导入IntelliJ-IDEA" class="headerlink" title="将源码导入IntelliJ IDEA"></a>将源码导入IntelliJ IDEA</h1><h2 id="导入IDEA前-配置"><a href="#导入IDEA前-配置" class="headerlink" title="导入IDEA前 - 配置"></a>导入IDEA前 - 配置</h2><ol><li><p>运行如下命令，生成IDE工程信息文件 <strong>android.ipr</strong> 和 <strong>android.iml</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> build/envsetup.sh <span class="comment"># 在新终端下需要执行这一步</span></span><br><span class="line">mmma development/tools/idegen</span><br><span class="line">development/tools/idegen/idegen.sh</span><br></pre></td></tr></table></figure></li><li><p>由于aosp工程很大，在导入IDEA前需要先修改配置：</p><ol><li><p>修改VM内存大小<br> 打开IDEA 菜单栏  Help &gt; Edit Custom VM Options，添加 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xms1g </span><br><span class="line">-Xmx5g</span><br></pre></td></tr></table></figure></li><li><p>修改文件大小限制，打开区分大小写选项<br> 打开IDEA 菜单栏 Help -&gt; Edit custom properties， 添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">idea.max.intellisense.filesize=100000</span><br><span class="line">idea.case.sensitive.fs=true</span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>NOTE:</strong> 重启IDEA使配置生效</p><ol start="3"><li>用IDEA找到AOSP目录下的<strong>android.ipr</strong>文件，打开AOSP工程，耐心等待，索引需要一定时间<h2 id="导入IDEA后-配置"><a href="#导入IDEA后-配置" class="headerlink" title="导入IDEA后 - 配置"></a>导入IDEA后 - 配置</h2></li><li>创建SDK 1.8 (No Libraries)，确保代码跳转到是aosp源码，而不是系统安装的JDK，如下<br><strong>NOTE</strong>  注意要删掉Classpath里面所有的jar<br><img src="http://blog.guotianqi.xyz/image/aosp_compile_on_mac/创建JDK1.8 (No Libraries" alt="创建JDK1.8 (No Libraries).png">.png)</li><li>删除Modules中的dependencies，只保留<code>&lt;Module source&gt;</code> 和 <code>1.8 (No Libraries)</code><br><img src="http://blog.guotianqi.xyz/image/aosp_compile_on_mac/删除Modules中的dependencies.png" alt="删除Modules中的dependencies.png"></li><li>将生成的资源文件ID目录<code>out/target/common/R</code>添加进源码目录，避免R资源索引找不到，如图：<br><img src="http://blog.guotianqi.xyz/image/aosp_compile_on_mac/添加资源文件R进源码目录.png" alt="添加资源文件R进源码目录.png"><h1 id="最后-Synchronize-整个工程同步下-打开IDEA菜单-File-gt-Synchronize-，稍稍等待后就可以愉快的阅读Android源码了。"><a href="#最后-Synchronize-整个工程同步下-打开IDEA菜单-File-gt-Synchronize-，稍稍等待后就可以愉快的阅读Android源码了。" class="headerlink" title="最后 Synchronize 整个工程同步下(打开IDEA菜单 File -&gt; Synchronize)，稍稍等待后就可以愉快的阅读Android源码了。"></a>最后 Synchronize 整个工程同步下(打开IDEA菜单 File -&gt; Synchronize)，稍稍等待后就可以愉快的阅读Android源码了。</h1></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;macOS High Sierra 版本 10.13.4&lt;/li&gt;
&lt;li&gt;Xcode 9.3&lt;/li&gt;
&lt;li&gt;aosp分支：android-8.1.0_r20&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;准备编译环境&quot;&gt;&lt;a href=&quot;#准备编译环境&quot; clas
      
    
    </summary>
    
      <category term="Android" scheme="https://guotianqi.xyz/categories/Android/"/>
    
    
      <category term="Android" scheme="https://guotianqi.xyz/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>JAVA单例（Singleton）实现的几种方式（多线程安全）</title>
    <link href="https://guotianqi.xyz/2018/05/24/java_thread_safe_singleton/"/>
    <id>https://guotianqi.xyz/2018/05/24/java_thread_safe_singleton/</id>
    <published>2018-05-24T15:12:44.000Z</published>
    <updated>2018-06-03T06:49:58.794Z</updated>
    
    <content type="html"><![CDATA[<p>主要分为两种：</p><ul><li>直接初始化</li><li>延迟初始化</li></ul><h1 id="直接初始化"><a href="#直接初始化" class="headerlink" title="直接初始化"></a>直接初始化</h1><h2 id="直接初始化final静态成员"><a href="#直接初始化final静态成员" class="headerlink" title="直接初始化final静态成员"></a>直接初始化final静态成员</h2><p><em>线程安全：JVM保证final静态成员只会被初始化一次</em></p><h3 id="公有静态成员是个final域，直接引用成员获取单例"><a href="#公有静态成员是个final域，直接引用成员获取单例" class="headerlink" title="公有静态成员是个final域，直接引用成员获取单例"></a>公有静态成员是个final域，直接引用成员获取单例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公有静态成员是个final域</span></span><br><span class="line"><span class="comment"> * 直接引用成员获取单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton1 INSTANCE = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造方法为private，避免用户用new构造出新对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton1.INSTANCE.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="公有的成员是个静态工厂方法，通过该方法获取单例。"><a href="#公有的成员是个静态工厂方法，通过该方法获取单例。" class="headerlink" title="公有的成员是个静态工厂方法，通过该方法获取单例。"></a>公有的成员是个静态工厂方法，通过该方法获取单例。</h3><p>提供了灵活性，在不改变API的前提下，可以改变该类是否应该为单例的想法。<br>比如改成为每个调用该方法的线程返回一个唯一的实例(<a href="https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html" target="_blank" rel="noopener"><code>ThreadLocal&lt;T&gt;</code></a>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公有的成员是个静态工厂方法，通过该方法获取单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton2 INSTANCE = <span class="keyword">new</span> Singleton2();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造方法为private，避免用户用new构造出新对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例的静态工厂方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Singleton2 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton2.getInstance().someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包含单个元素的枚举类型-enum"><a href="#包含单个元素的枚举类型-enum" class="headerlink" title="包含单个元素的枚举类型(enum)"></a>包含单个元素的枚举类型(enum)</h2><p>由枚举类型的性质保证枚举常量<code>INSTANCE</code>是唯一实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个包含单个元素的枚举类型</span></span><br><span class="line"><span class="comment"> * 枚举类型保证每个枚举常量都是一个单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123; <span class="comment">/** .... */</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSingleton.INSTANCE.someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="延迟初始化"><a href="#延迟初始化" class="headerlink" title="延迟初始化"></a>延迟初始化</h1><h2 id="直接在静态工厂方法上加-synchronized。缺点：每次调用都有线程开销"><a href="#直接在静态工厂方法上加-synchronized。缺点：每次调用都有线程开销" class="headerlink" title="直接在静态工厂方法上加 synchronized。缺点：每次调用都有线程开销"></a>直接在静态工厂方法上加 <code>synchronized</code>。<em>缺点：每次调用都有线程开销</em></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟初始化单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitSingleton1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyInitSingleton1 INSTANCE;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认构造方法为private，避免用户用new构造出新对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInitSingleton1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例的静态工厂同步方法</span></span><br><span class="line"><span class="comment">     * 延迟初始化单例</span></span><br><span class="line"><span class="comment">     * 使用同步方法保证多线程操作只实例化一个实力</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> LazyInitSingleton1 单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazyInitSingleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> LazyInitSingleton1();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">someMethod</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton2.getInstance().someMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lazy-initialization-holder-class-模式。（参考《Effective-Java》第71条：慎用延迟初始化"><a href="#lazy-initialization-holder-class-模式。（参考《Effective-Java》第71条：慎用延迟初始化" class="headerlink" title="lazy initialization holder class 模式。（参考《Effective Java》第71条：慎用延迟初始化"></a>lazy initialization holder class 模式。（参考《Effective Java》第71条：慎用延迟初始化</h2><p><em>优点：避免同步方法的开销</em>。<br><code>getInstance</code>第一次被调用时，读取<code>SingletonHolder.field</code>，导致<code>SingletonHolder</code>类得到初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lazy initialization holder class 模式</span></span><br><span class="line"><span class="comment"> * 避免同步方法的开销</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitSingleton2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> LazyInitSingleton2 field = computeFieldValue();</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LazyInitSingleton2 <span class="title">computeFieldValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> LazyInitSingleton2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInitSingleton2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInitSingleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.field;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="双重检测，降低同步方法开销。（参考《Effective-Java》第71条：慎用延迟初始化"><a href="#双重检测，降低同步方法开销。（参考《Effective-Java》第71条：慎用延迟初始化" class="headerlink" title="双重检测，降低同步方法开销。（参考《Effective Java》第71条：慎用延迟初始化"></a>双重检测，降低同步方法开销。（参考《Effective Java》第71条：慎用延迟初始化</h2><p>INSTANCE 使用 volatile 修饰符：防止JVM的即时编译器对<code>INSTANCE = new LazyInitSingleton3()</code>操作进行指令重排序。  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 延迟初始化，双重检测，降低同步方法开销</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyInitSingleton3</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注意：使用了 volatile 修饰符</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazyInitSingleton3 INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyInitSingleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyInitSingleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一次判断无需同步，如果 INSTANCE 已经被初始化，</span></span><br><span class="line">        <span class="comment">// 就直接返回，没有同步开销</span></span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果判断为空（多线程并发执行 getInstance，导致很多线程判断外层INSTANCE == NULL）</span></span><br><span class="line">            <span class="keyword">synchronized</span> (LazyInitSingleton3.class) &#123;</span><br><span class="line">                <span class="comment">// 进入同步后再判断一次，</span></span><br><span class="line">                <span class="comment">// 保证只有一个线程赋值给 INSTANCE，</span></span><br><span class="line">                <span class="comment">// 后续进来执行的线程都会判断 INSTANCE != NULL，不会再赋值</span></span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> LazyInitSingleton3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="为什么INSTANCE要使用volatile修饰符"><a href="#为什么INSTANCE要使用volatile修饰符" class="headerlink" title="为什么INSTANCE要使用volatile修饰符"></a>为什么INSTANCE要使用<code>volatile</code>修饰符</h3><p>在JVM中，new操作做了下面3件事：</p><ol><li>给要<code>new</code>的对象<code>LazyInitSingleton3</code>分配内存空间</li><li>调用<code>LazyInitSingleton3</code>的构造函数来初始化对象</li><li>将INSTANCE指向步骤1中分配的内存空间  </li></ol><p>由于JVM存在指令重排序的优化，上面第2步和第3步顺序是无法保证的（1-2-3或者1-3-2）。<br>如果执行步骤是1-3-2，那么假设线程A执行到第3步，但第2步还未执行，此时线程B调用<code>getInstance()</code>发现<code>INSTANCE</code>非空（<strong>但未被初始化</strong>），直接返回<code>INSTANCE</code>，之后线程B对<code>INSTANCE</code>操作可能会发生错误（由于对象还未被初始化）。<br><code>volatile</code>修饰符防止指令重排序的优化，保证执行顺序是1-2-3。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接初始化&lt;/li&gt;
&lt;li&gt;延迟初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;直接初始化&quot;&gt;&lt;a href=&quot;#直接初始化&quot; class=&quot;headerlink&quot; title=&quot;直接初始化&quot;&gt;&lt;/a&gt;直接初始化&lt;/h1&gt;&lt;h2 i
      
    
    </summary>
    
      <category term="设计模式" scheme="https://guotianqi.xyz/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://guotianqi.xyz/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Java" scheme="https://guotianqi.xyz/tags/Java/"/>
    
  </entry>
  
</feed>
